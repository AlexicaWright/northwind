= Learn graph fundamentals with Neo4j


== Let's get started

This guide will teach you about the power of graph databases. We recommend it as the starting place for all new users as it will touch upon the concepts and tools you need to work with graphs. 

=== What you will learn

This guide will take around 10 minutes and by the end of it you will:

- Understand the *graph property model* and what problems it can help you solve.
- Learn how to convert an understanding of a relational database model to a graph.
- Import and model data from CSV files and map them to a graph.
- Visually explore that data, without code, in a graph. 
- Write your first simple graph queries using *Cypher*.

=== Let's get started! 

We will be using the classic relational dataset known as Northwind. It's time to bring this dataset and fictional company into an exciting graph-enabled future.


== What is a graph?

=== Concepts

A graph database stores *nodes* (`Customer`, `Product`, etc) and their *relationships* (e.g. `Customer PURCHASED Product`). 

Unlike other types of database, which may use tables or documents, in a graph data is stored just like you might sketch ideas on a whiteboard.

image::https://github.com/neo4j-graph-examples/northwind/raw/main/documentation/img/model.svg[]

In relational databases, the relationships between rows and other tables are not stored. Instead, you must write queries that use a `join`. These operations can be complex, slow, and expensive. 

In a graph, you get them insantly and for free. This has powerful implications for many data-driven applications. 

=== Schema free

In a relational database, you must define your schema (the structure of the data). In a graph, your data is managed without restricting it to a pre-defined schema. This allows a very flexible way of thinking and evolving it.


== Nodes, properties, relationships

The nodes and relationships in your graph can have *Types* and *Properties*. 

=== Nodes and Properties

Nodes can be tagged with *Labels*, representing their different roles in your dataset (e.g. `Supplier`, `Employee`, `Customer`). 
They can also hold any number of key-value pairs as *Properties*. (`name:"Jane"`).

=== Relationships

*Relationships* provide directed, typed, or attributed, connections between two node entities (e.g. `Shipper SHIPS Order`).

Relationships always have a *direction*, a *type*, a start node, and an end node. They can also hold properties, just like nodes.

Nodes can have any number of relationships without sacrificing performance. 

Although relationships are always directed, they can be navigated efficiently in any direction.

In our example, you could find who shipped an order; you could also reverse that and find what orders were
shipped.


== Re-imagining a classic (Northwind)

// await signals.emit(SIGNAL_NAME.WorkspaceNavigate, { scope: APP_SCOPE.import });

image::https://neo4j-graph-examples.github.io/northwind/documentation/img/product-category-supplier.png[]

The classic Northwind dataset represents an online shop. You're going transform this relational database example into a graph database. 

image::https://neo4j-graph-examples.github.io/northwind/documentation/img/product-graph.png[]

////
.TODO diagram of Northwind customer, order, and product
image::https://github.com/neo4j-graph-examples/northwind/blob/main/documentation/img/example.svg[]
////

Click the button to download a zip file with the CSVs and an initial graph model we have prepared for you.

////
TODO:  Button Download the Northwind dataset
////

Drag the zip file into the left file sidebar of the import tab on the left.

You can now see the CSV files from Northwind's tables represented as a graph model. 

Notice the relationships connecting the nodes: a `Customer PURCHASED an Order` and the `Order CONTAINED Products`.

image::https://neo4j-graph-examples.github.io/northwind/documentation/img/model.svg[]

== Finish the Northwind import

For each node and relationship in the model you can see which parts of the CSV file are mapped to which properties.

To connect Nodes with Relationships we use source and target ids from the original join tables or foreign keys.

The model is interactive; you click around and explore its Nodes and Relationships. 

=== Preview your data import

You can see a preview of the data import by clicking the *Preview Graph* button that allows you to check node labels, the property names and values, and relationship types and directions.

If you're satisfied, click the *Run Import* button to load your data into your graph.

Don't worry if something goes wrong, the tool can import the same data multiple times and you can reset your database to blank in the AuraDB Console.

// A/B Test: TBD we could leave off one simple mapping, e.g. shipper and let the user do it (or prepare the node without mapping the rel and properties (but pick one that lends itself well to auto-mapping) in an area of the model that is non-crucial for later steps but not sure if that would have too many folks fail here

=== Explore your data

After you have imported the Northwind dataset, click the *Explore the Import Results* button in the report popup or switch to the *Explore* tab. 

It's time see the power of graph visualization.

// TODO button switch to explore

== Explore your graphs

Now that your data is in the graph, let's get familiar with in the *Explore* tab.

The `Show me a graph` search phrase should have been run automatically to show an example subset of the data.

You can also run it yourself in the top-left search bar.

=== Searching for data in Explore

You can use simple search phrases based on your node labels and relationship types to visualize your graph.

Try to enter `Category<tab>` and then press return; it should fetch and display all categories. 

Which you now can explore and expand the graph visualization. 

This is a great way to discover interesting relationships and formulate questions about your data. 

///TODO captions!!

One neat feature is to select two nodes (`Shift-Click`) and select *Paths -> Shortest Path* from the right-click context menu on one of them.

// TBD educate about paths in search box!

You can select all `Categories` by clicking on their box in the right side legend and then choose *Expand -> All* in the context menu to see all the products contained in these categories.

That context menu also offers many more options like editing, partial expansion, clearing the scene or dismissing (un-)selected. nodes.

== Advanced exploration

Above the zoomed out view, you can switch between layouts.

You can style your data in the right legend using colors, icons, sizes, captions and even apply rules for these.
Try to click on `Category` in the Legend and pick a different color, icon and size for your nodes.

Selected nodes and relationships are highlighted and counted in the legend and shown in the card view in the lower left corner. 
There you can explore your data structurally.

*Explore* also offers options to filter your on-screen nodes with a advanced filter menu, and even rudimentary end user programming by storing *Cypher Phrases* to be available later.

Learn more in the https://neo4j.com/docs/bloom-user-guide/current/bloom-visual-tour/[documentation^] and videos.

// TODO switch to Query

== Basic Querying

On the left sidebar in the first entry (database) you can see the counts of types of nodes and relationships.
Click on `(Product)` - the database will fetch a few  elements with that label with a minimal query.

.Load query for product nodes
[source,cypher]
----
MATCH (n:Product) 
RETURN n 
LIMIT 25
----

In the *graph view* the result nodes are visualized and you can double-click them to see their neighbors. 
In the right properties side-panel you can inspect more properties and also style the nodes (size, color, caption) if you click on the `(Product)` label on top.

You can also switch to the *table view* to see your results in a tabular fashion, nodes and relationships are visualized in a JSON structure.
That view shows by default if you return only scalar values.

// TBD Alternatively we could have them click on [:SUPPLIES] and then they would already see a graph visualization, it would use graph patterns and pattern variable, but it might be too complex. I would actually prefer this one.
// See screenhots below.

== Writing your first query

Like any other database Neo4j can be queried with a query language. 
As SQL joins get really convoluted for graphs, our graph query language called *Cypher* is much better suited for finding patterns.

In Cypher you represent the graph patterns that you've seen in Import and Explore with ascii-art. 

Parentheses `(p:Product {name:'Camembert Pierrot'})` forming "circles" around nodes and arrows `+-[:SUPPLIES]->+` depicting relationships. 
You draw in text what you would draw on the whiteboard.

These patterns are used to find, create and update graph data.

You've already seen the `MATCH (n:Product) RETURN n LIMIT 25` statement that was run for you.

Click on the statement to edit it and change the pattern to: `(n:Product)<-[r:SUPPLIES]-(s:Supplier)` and the result to `RETURN n,r,s LIMIT 25` and click on the run icon icon:PlayIcon[].

Congratulations, you've written and run your first Cypher query.

.Show products and their suppliers
[source,cypher]
----
MATCH (n:Product)<-[r:SUPPLIES]-(s) 
RETURN n,r,s 
LIMIT 25
----

To learn more about Cypher check out the interactive https://graphacademy.neo4j.com/categories/beginners/[GraphAcademy course^] and have a look at the https://neo4j.com/docs/cypher-cheat-sheet/current/[Cypher Cheat Sheet^].

A more complex query would find all products ordered by a customer and who supplies those.

.All products ordered by a customer and who supplies those
[source,cypher]
----
MATCH path=(c:Customer)-[:PURCHASED]->()-[:ORDERS]->(:Product)<-[:SUPPLIES]-(:Supplier)
WHERE c.companyName = 'Blauer See Delikatessen'
RETURN path;
----

image::https://neo4j-graph-examples.github.io/northwind/documentation/img/example.svg[]

Or how many products in the "Produce" category each customer ordered.

.Find total quantity per customer in the "Produce" category
[source,cypher]
----
MATCH (cust:Customer)-[:PURCHASED]->(:Order)-[o:ORDERS]->(p:Product),
      (p)-[:PART_OF]->(c:Category {categoryName:"Produce"})
RETURN DISTINCT cust.contactName as CustomerName, SUM(o.quantity) AS TotalProductsPurchased
----

As you get more familiar with Cypher, you can use the https://neo4j.com/docs/drivers-apis/[Neo4j drivers^] for JavaScript, Python, Java, C# and Go to build your applications, or use our GraphQL or Spring Data Neo4j integrations for building APIs.